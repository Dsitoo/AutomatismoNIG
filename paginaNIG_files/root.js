/**
 * The root.js contains the main root object. The root.js will be included into
 * every root frame of dynamic JSF pages, ideally this is only one page. This DynJSFRoot 
 * should be available on every dynamic JSF page.<br>
 * The root object handles the blocking of the client, gives access to global
 * objects and captures events to handle them.
 */

var localObjects = new Array();

DynJSFRoot = {
	//this function instead of a constructor
	/**
	 * Initialises the root object
	 */
	init : function() {
		this.blocker = document.createElement("div");
		// mod BP 2010
		$(this.blocker).css({'position': "absolute"});
		// end mod BP 2010
		this.blocker.className = "blocker";
		this.blocker.id = "blocker";
		if (dynamicPage) {
			document.body.appendChild(this.blocker);
		}
		this.blocker.onmousedown = function(event) { return false; };
		this.blocker.onmouseup = function(event) { return false; };
		this.blocker.onmousemove = function(event) { return false; };
		this.blocker.onclick = function(event) { return false; };
		this.blocker.onkeydown = function(event) { return false; };
		this.blocker.onkeyup = function(event) { return false; };
		this.blocker.onkeypress = function(event) { return false; };
		this.blocker.oncontextmenu = function(event) { return false; };
		
		this.cancelWindow = document.createElement("iframe");
		this.cancelWindow.className = "cancelWindow";
		this.cancelButton = null;
		this.cancelWindow.src = "modules/dynjsf/resource/CancelWindow.html";
		this.lblCancel = "Cancel";
		this.lblCancelling = "Cancelling...";

		this.cancelFunctions = new Array();
		
		this.objectsToCollapse = new Array();
		
		this.blocked = true;
		this.blockerCounter = 0;
		this.initialRequest = false;
		this.mapRequestPending = 0;

		this.objectsToBlock = new Array();

		this.timeout = null;
		
		this.dynObjects = new Array();
		this.dynId = 1;
		
		this.reloadForms = new Array();
		
		this.debug = false;
		this.contextDisable = false;
		
		this.stamp = (new Date()).getTime();
		//values < 24 might appear a bit laggy
		this.maxFrames = 24;
		this.minWait = Math.floor(1000 / this.maxFrames);

		this.menuLayer = new Array();
		this.menuIFrame = new Array();
		
		this.blockKey = false;
		this.oldBlockKey = false;
		
		this.shift = false;		
		
		this.language = "";
		
		// part of request URL that identifies the web application, for example: /SIAS-Client
		this.contextPath = null;
		// Application URL, for example: http://localhost:8080/SIAS-Client
		this.URL = null;
		
		this.document = document;
		this.window = window;
		
		this.setServerBlocker();
	},

	/**
	 * Adds a form to reload. This method is called by the DynamicBodyRenderer.
	 * @ignore
	 */
	addReloadForm : function(obj) {
		this.reloadForms.push(obj);
	},
	
	/**
	* Increments a counter for pending Map requests that are calling releaseServerBlocker.
	* This method is only called by checkResize() in fullsize.js in case of a resize event.
	* @ignore
	*/
	// Fixes issue CBG00122552
	_setMapRequestPending: function(){
		if(!this.initialRequest){
			this.mapRequestPending++;
		}
		this.setServerBlocker();
		//alert("pending:" + this.mapRequestPending);
	},
	
	/**
	 * Initial request is used on the first initialisation of the client, 
	 * as releaseServerBlocker is only called once instead of twice in this case.
	 * @ignore
	 */
	// Fixes issue CBG00122552
	_setInitialRequest: function(){
		this.initialRequest= true;
	},
	
	/**
	 * Sets the server blocker. Normally this method should only be called by a 
	 * submitting form, should only be called by custom form tags.
	 */
	setServerBlocker : function() {
		//console.log("setServerBlocker");
		//this.blocker.style.backgroundColor = "lime";
		this.blocked = true;
		this.block();		
	},
	/**
	 * Releases the server blocker. Will be called when a page is loaded. 
	 * Normally a call is generated by the DynamicBodyRenderer.
	 * @ignore
	 */
	releaseServerBlocker : function() {
		// Reset the cancel functions, they are not valid anymore
		this.cancelFunctions = [];

		this.mapRequestPending--;

		if(this.mapRequestPending<=0 || this.initialRequest){
			this.mapRequestPending = 0;
			this.blocked = false;
		}
		this.initialRequest = false;
		//alert("pending:" + this.mapRequestPending);
		this.block();		
	},
	/**
	 * Sets the client blocker. This can be used to block 
	 * the client independently from any server communication.
	 * Keep in mind to call releaseClientBlocker() after all.	 
	 */
	setClientBlocker : function() {
		//console.log("setClientBlocker");
		//this.blocker.style.backgroundColor = "red";
		this.blockerCounter++;
		this.block();		
	},
	/**
	 * Releases the client blocker. Setting and releasing should 
	 * be used always in pairs.
	 */
	releaseClientBlocker : function() {
		if (this.blockerCounter > 0 ) {
			this.blockerCounter--;			
		}
		this.block();		
	},
	/**
	 * Internal blocking function called after each blocking process.
	 * Checks if the client should be blocked or not and does all blocking.
	 * @ignore
	 */
	block : function() {
		if (this.blocked || this.blockerCounter > 0) {
			//console.log("block()");
			try {
				$(this.blocker).css({'visibility':"visible",'display':"block"});
				$(this.cancelWindow).css({'top': this.blocker.offsetHeight / 2 - 41,'left': this.blocker.offsetWidth / 2 - 80});
				// Initially do not display the activity icon and cancel button
				$(this.cancelWindow).css({'visibility': "hidden",'display': "none"});
				this.blocker.appendChild(this.cancelWindow);
				this.cancelButton.disabled = false;
				this.cancelButton.value = this.lblCancel;
				// Delay the display of the cancel button and activity icon
				// by the given amount of milli-seconds.
				setTimeout("root.showCancelWindow()",1500);
			} catch(ex) {}
		} else {
			try {
				$(this.blocker).css({'visibility': "hidden",'display': "none"});
				if (this.timeout) {
					window.clearTimeout(this.timeout);
				}
			} catch(ex) {}
		}
	},
	/** Makes the cancel button and activity icon visible. */ 
	showCancelWindow : function(){
		if (this.cancelWindow) {
			$(this.cancelWindow).css({'visibility': "visible",'display': "inline"});
		}
		this.cancelButton.focus();
	},

	/**
	 * Returns whether the client id is currently blocked.
	 * @return true if the client id is currently blocked.
	 */
	isBlocked : function() {
		return (this.blocked || this.objectBlocking) ;
	},
	
	/**
	 * Registers an object that should be blocked during blocking by the method blockObjects.
	 */
	addObjectToBlock : function(obj) {
		this.objectsToBlock[obj.id] = obj;
	},
	/**
	 * Un-registers an object from blocking by the method blockObjects.
	 */
	removeObjectToBlock : function(obj) {
		try{
			this.objectsToBlock[obj.id] = null;
		} catch(e) {}
	},
	/**
	 * Blocks or unblocks all registered objects.
	 * This is typically implemented by the objects by activating and maximising a block layer or HTML div.
	 * This method typically is called when 
	 * a modal window is opened and wants to block other objects.
	 * @param block boolean which indicates whether to block or unblock
     * @param blocker the object (normally a modal window) which causes un/blocking of other objects.
	 */
	blockObjects : function(block, blocker) {
		this.objectBlocking = block;
		for (var e in this.objectsToBlock) {
			if(this.objectsToBlock[e] != null){
				if(blocker==null || !this.objectsToBlock[e].id.startsWith(blocker.id)){
					this.objectsToBlock[e].block(block, blocker);
				}
			}
		}
	},
	 
	/**
	 * Returns the local objects, these are all registered 
	 * objects beginning with the given frameId.
	 * @param frameId Id of the frame (page)
	 */
	getLocalObjects : function(frameId) {
		var objects = new Array();
		for (var e in this.dynObjects) {
			obj = this.dynObjects[e];
			try {
				if (obj.id.substring(0, frameId.length) == frameId) {
					objects.push(obj);
				}
			} catch(ex) {}
		}
		return objects;
	},
	/**
	 * Returns a specific local object with the given objId. Calls
	 * getLocalObjects to get a list of all objects.
	 * @return the local object or null
	 */
	getLocalObject : function(objId) {
		var i;
		if (localObjects.length == 0) {
			localObjects = root.getLocalObjects(frameId);
		}
		for (i = 0; i < localObjects.length; i++) {
			obj = localObjects[i];
			try {
				if (obj.id.substring(obj.id.length-objId.length, obj.id.length) == objId) {
					return obj;
				}
			} catch(ex) {}
		}
		return null;
	},
	/**
	 * Returns a object from the dynObjects.
	 * @param obj if obj is an object, obj.id is used as the key, 
	 * 		otherwise obj itself is assumed as key.
	 * @return the requested object or null 
 	 */
	getObject : function(obj) {
		try {
			if (typeof(obj)=='object') {
				return this.dynObjects[obj.id];
			} else {
				return this.dynObjects[obj];
			}
		} catch (ex) {
			return null;
		}
	},
	/**
	 * Returns the string value of an object in dynObjects.
	 * @ignore
	 */
	objectsToString : function(obj) {
		var output = "";
		for (var e in this.dynObjects) {
			output += e+" - "+this.dynObjects[e]+"\n";
		}
		return output;
	},
	/**
	 * Returns a element by id. Short(?) form for 
	 * document.getElementById(id) 
	 */
	getElementById : function(id) {
		return document.getElementById(id);
	},
	/**
	 * Registers an object in the dynObjects array. If this object 
	 * has no id, it will get a dynamically created one. The object is
	 * stored in the dynObjects Array with its id as key.
	 * @param the object to store 
	 */
	registerObject : function(obj) {
		if (obj) {
			if (obj.id == null) {
				while (this.dynObjects[++this.dynId] != null) { }
				obj.id = this.dynId;
			}
			this.dynObjects[obj.id] = obj;
		}
	},
	/**
	 * Submits the reload forms. Used only by the DynamicBodyRenderer.
	 * @ignore
	 */
	submitReloadForms : function() {
		var i;
		for (i = 0; i < this.reloadForms.length; i++) {
			try {
				root.setServerBlocker();
				this.reloadForms[i].submit();
			} catch(ex) {}
		}
		this.reloadForms = new Array();
	},

	/**
	 * Causes all registered objects to collapse, for example opened menus or drop down buttons. 
	 * Should be called on all events where menus etc. should be closed.
	 */
	collapse : function() {		
		var i;
		for (var e in this.objectsToCollapse) {
			try {
				this.objectsToCollapse[e].collapse();
			} catch(ex) {
			}
		}
		this.objectsToCollapse = [];
		for (i=0; i<this.menuLayer.length; i++) {
			// end BP 2010
			$(this.menuLayer[i]).css({'visibility':"hidden"});
			$(this.menuIFrame[i]).css({'visibility':"hidden"});
			// end mod BP 2010
		}
	},
	/**
	 * Registers an object (for example an open menu) that should be collapsed by the method collapse().
	 */
	markToCollapse : function(object) {
		if (object) {
			this.objectsToCollapse.push(object);
		}
	},

	/**
	 * Returns the layer for the menu. All menus share the iframes 
	 * with the same depth. Should only be used by dynjsf menu / toolbar.
	 * @ignore
	 */
	getMenuLayer : function(step) {
		var i;
		if (this.menuLayer.length < step) {
			for (i=0; i<step; i++) {
				if (this.menuLayer[i] == null) {
					this.menuLayer[i] = createLayer("menuitem", "div", "menuLayer_"+(i+1));
					// mod BP 2010
					$(this.menuLayer[i]).css({'position': "absolute"});
					// end mod BP 2010
					document.body.appendChild(this.menuLayer[i]);
					this.menuIFrame[i] = createLayer("iFrameLayer", "div", "menuIFrameLayer_"+(i+1));
					// mod BP 2010
					$(this.menuIFrame[i]).css({'position': "absolute",'overflow': "hidden"});
					// end mod BP 2010
					document.body.appendChild(this.menuIFrame[i]);
					this.menuIFrame[i].innerHTML = '<iframe class="iFrameLayer"  width="100%" height="100%" src="about:blank"></iframe>';
					this.menuLayer[i].iFrameLayer = this.menuIFrame[i];
				}
				// mod BP 2010
				$(this.menuLayer[i]).css({'zIndex': i +10});
				$(this.menuIFrame[i]).css({'zIndex': i + 9});
				// end mod BP 2010
			}
		} else {
			for (i=step; i<this.menuLayer.length; i++) {
				// mod BP 2010
				$(this.menuLayer[i]).css({'visibility': "hidden"});
				$(this.menuIFrame[i]).css({'visibility': "hidden"});
				// end mod BP 2010
			}
		}
		// mod BP 2010
		$(this.menuLayer[step-1]).css({'visibility': "visible"});
		$(this.menuIFrame[step-1]).css({'visibility': "visible"});
		// end mod BP 2010
		return this.menuLayer[step-1];
	},
	/**
	 * Removes an object from the dynObjects array.
	 */	
	unregisterObject : function(obj) {
		try {
			if (typeof(obj)=='object') {
				this.dynObjects[obj.id] = null;
				if (obj.unload) {
					obj.unload();
				}
				delete obj;
			} else {
				this.unregisterObject(this.dynObjects[obj]);
			}
		} catch (ex) {}
	},
	/**
	 * Sets a flag for block key. Is used for any input fields, where 
	 * not all keys should be blocked.
	 * @ignore
	 */
	setBlockKey : function() {	
		if (this.blockKey) {
			this.oldBlockKey = true;
		}			
		this.blockKey = true;
		return true;
	},
	/**
	 * Un-sets a flag to block key.
	 * @ignore
	 */
	unsetBlockKey : function() {		
		if (this.oldBlockKey) {
			this.oldBlockKey = false;
		} else {
			this.blockKey = false;			
		}
		return true;
	},
	/**
	 * Sets a flag for shift, indicating if shift is currently pressed.
	 * Should not be set by any other.
	 * @ignore 
	 */
	setShift : function() {
		this.shift = true;
	},
	/**
	 * Un-sets a flag for shift, see above:
	 * @ignore
	 */
	unsetShift : function() {
		this.shift = false;
	},

	/**
	 * Handles the keyDown action. Should not be modified or used in any other way.
	 * @ignore
	 */
	handleOnKeyDownEvent : function(evnt) {
		evnt = evnt || window.event;		
		try {
			if (evnt.shiftKey) {
	    		root.setShift();
	    	}	    	
			if (keymap == undefined) {
				var keymap = root.getObject('globalKeymap');
			}
			keymap.handelKeyDownEvent(evnt);
		} catch (exc) {
		}
	},
	/**
	 * Handles the keyUp action. Should not be modified or used in any other way.
	 * @ignore
	 */
	handleOnKeyUpEvent : function(evnt) {
		if (root.shift && !evnt.shiftKey) {
	    	root.unsetShift();
	    }	   
		if (keymap == undefined) {
			var keymap = root.getObject('globalKeymap');
		}
		if (keymap) {
			keymap.handelKeyUpEvent(evnt);
		}
    },	  
	/**
	 * Handles the keyPress action. Should not be modified or used in any other way.
	 * @ignore
	 */
	handleOnKeyPressEvent : function(evnt) {
		if (root.shift && !evnt.shiftKey) {
	    	root.unsetShift();
	    }	   
		if (keymap == undefined) {
			var keymap = root.getObject('globalKeymap');
		}
		if (keymap) {
			keymap.handelKeyPressEvent(evnt);
		}
    },	  

    /**
	 * Handles the MouseDown action. 
	 * Calls root.collapse() to close, for example opened menus or drop down buttons.
	 */
	handleOnMouseDownEvent : function(evnt) {
		root.collapse();
    },	

    /**
	 * Cancel a request if the tag is used. Otherwise only releases the blocker.
	 * @param the button that was pressed for cancelling
	 */
	cancelRequest : function(button) {
		this.clientBlocker = 0;
		if(button != null){
			this.cancelButton = button;
			button.disabled = true;
			button.value = this.lblCancelling;
		}
		while (this.cancelFunctions.length > 0) {
			var func = this.cancelFunctions.pop();
			try {
				if (typeof(func) == "string") {
					eval(func);
				} else {
					func();
				}
			} catch (ex) { alert(ex.message); }
		}
		this.releaseServerBlocker();
		try {
			this.getObject("requestCancel").click();
			document.body.appendChild(this.cancelWindow);
		} catch(ex){}
	},
	setCancelLabels : function(lbl1, lbl2) {
		this.lblCancel = lbl1;
		this.lblCancelling = lbl2;
		if (this.cancelButton!=null) {
			this.cancelButton.value = lbl1;
		}
	},
	setCancelButton : function(button) {
		this.cancelButton = button;
		button.value = this.lblCancel;
	},
	/**
	* Ends a cancel request, should be called from server, if cancel is complete.
	*/ 
	endCancelRequest : function() {
		try {
			document.body.removeChild(this.cancelWindow);
		} catch(ex){}
	},
	/**
	* Adds a function that will be called when the request is cancelled.
	*/
	addCancelFunction : function(method) {
		this.cancelFunctions.push(method);
	},

	/**
	 * Returns the language of the browser including country information (if any).
	 */
	getLanguage : function() {
		return this.language;
	},

	/** Returns the context path. That is the part of request URL that identifies 
	 * the web application, for example: /SIAS-Client or /SIAS-Client-rl */
	getContextPath : function() {
		return this.contextPath;
	},

	/** Returns the application URL, for example:
	 *  http://localhost:8080/SIAS-Client
	 */
	getURL : function() {
		return this.URL;
	}
};

// mod BP 2010
// needed from this.cancelWindow.src = "modules/dynjsf/resource/CancelWindow.html";
// onload event
if (dynamicPage){
	var root = DynJSFRoot;
	}
// end mod BP 2010

DynJSFRoot.init();

// Set some global variables for the portlet mode
if (typeof objectListerPortletLoaded == "undefined"){
	var objectListerPortletLoaded = false;
}

if (typeof mapPortletLoaded == "undefined"){
	var mapPortletLoaded = false;
}

if (typeof locatorPortletLoaded == "undefined"){
	var locatorPortletLoaded = false;
}

if((!locatorPortletLoaded) &&(!objectListerPortletLoaded) && (!mapPortletLoaded) && (!dynamicPage)){
	var root = DynJSFRoot;
}

//mod BP 2010
//if (dynamicPage){
//var root = DynJSFRoot;
//}
//end mod BP 2010

/**
 * Handles the mousedown event by calling root.handleOnMouseDownEvent(evnt) 
 * which collapses menus and drop downs buttons.
 */
document.onmousedown = function(evnt) {
	evnt = evnt || window.event;
	root.handleOnMouseDownEvent(evnt);
};

/** Handles the onkeydown event by calling root.handleOnKeyDownEvent(evnt). */
document.onkeydown = function(evnt) {
	evnt = evnt || window.event;
	root.handleOnKeyDownEvent(evnt);
};

/** Handles the onkeyup event by calling root.handleOnKeyUpEvent(evnt). */
document.onkeyup = function(evnt) {
	evnt = evnt || window.event;
	root.handleOnKeyUpEvent(evnt);
};

/** Handles the onkeypress event by calling root.handleOnKeyPressEvent(evnt). */
document.onkeypress = function(evnt) {
	evnt = evnt || window.event;
	root.handleOnKeyPressEvent(evnt);
};
